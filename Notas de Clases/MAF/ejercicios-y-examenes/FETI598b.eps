%!PS-Adobe-2.0 EPSF-2.0
%%Title: Untitled
%%Creator: Draw
%%CreationDate: Wed Oct 21 14:04:52 1998
%%For: rodolfo
%%DocumentFonts: (atend)
%%Pages: 0 0
%%BoundingBox: 38 557 309 668
%%NXNextStepVersion: 3.0
%%EndComments

%%BeginProcSet: /NextLibrary/Frameworks/AppKit.framework/Versions/B/Resources/printPackage.ps 3.0
%!
%
%	printPackage.ps
%	Application Kit
%	Copyright (c) 1988-1996, NeXT Software, Inc.
%	All rights reserved.
%

/__NXdef{1 index where{pop pop pop}{def}ifelse}bind def
/__NXbdef{1 index where{pop pop pop}{bind def}ifelse}bind def
/UserObjects 10 array __NXdef
/defineuserobject{
	exch dup 1 add dup UserObjects length gt{
		array dup 0 UserObjects putinterval
		/UserObjects exch def
	}{pop}ifelse UserObjects exch 3 -1 roll put
}__NXbdef
0 0 defineuserobject
1 null defineuserobject
/undefineuserobject{UserObjects exch null put}__NXbdef
/execuserobject{UserObjects exch get exec}__NXbdef
/__NXRectPath{4 2 roll moveto 1 index 0 rlineto
0 exch rlineto neg 0 rlineto closepath}__NXbdef
/__NXProcessRectArgs{
	1 index type /arraytype eq{
		exch 0 4 2 index length 1 sub{
			dup 3 add 1 exch{1 index exch get exch}for
			5 1 roll 5 index exec
		}for pop pop
	}{exec}ifelse
}__NXbdef
/rectfill{gsave newpath {__NXRectPath fill} __NXProcessRectArgs grestore}__NXbdef
/rectclip{newpath {__NXRectPath} __NXProcessRectArgs clip newpath}__NXbdef
/rectstroke{
	gsave newpath dup type /arraytype eq{dup length 6 eq}{false}ifelse{
		{gsave __NXRectPath null concat stroke grestore}
		dup length array cvx copy dup 2 4 -1 roll put __NXProcessRectArgs
	}{{__NXRectPath stroke} __NXProcessRectArgs}ifelse grestore
}__NXbdef
/_NXLevel2 systemdict /languagelevel known {languagelevel 2 ge}{false}ifelse __NXdef
/xyshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index 2 mul 1 add get add exch
		3 index	3 index 2 mul get add exch moveto pop
	}for pop pop
}__NXbdef
/xshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		exch 3 index 3 index get add exch moveto pop
	}for pop pop
}__NXbdef
/yshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index get add moveto pop
	}for pop pop
}__NXbdef
/arct{arcto pop pop pop pop}__NXbdef
/setbbox{pop pop pop pop}__NXbdef
/ucache{}__NXbdef
/ucachestatus{mark 0 0 0 0 0}__NXbdef
/setucacheparams{cleartomark}__NXbdef
/uappend{systemdict begin cvx exec end}__NXbdef
/ueofill{gsave newpath uappend eofill grestore}__NXbdef
/ufill{gsave newpath uappend fill grestore}__NXbdef
/ustroke{
	gsave newpath dup length 6 eq
	{exch uappend concat}{uappend}ifelse
	stroke grestore
}__NXbdef
/__NXustrokepathMatrix dup where {pop pop}{matrix def}ifelse
/ustrokepath{
	newpath dup length 6 eq{
		exch uappend __NXustrokepathMatrix currentmatrix exch concat
		strokepath setmatrix
	}{uappend strokepath}ifelse
} __NXbdef
/upath{
	[exch {/ucache cvx}if pathbbox /setbbox cvx
	 {/moveto cvx}{/lineto cvx}{/curveto cvx}{/closepath cvx}pathforall]cvx
} __NXbdef
/setstrokeadjust{pop}__NXbdef
/currentstrokeadjust{false}__NXbdef
/selectfont{exch findfont exch
dup type /arraytype eq {makefont}{scalefont}ifelse setfont}__NXbdef
/_NXCombineArrays{
	counttomark dup 2 add index dup length 3 -1 roll {
		2 index length sub dup 4 1 roll 1 index exch 4 -1 roll putinterval exch
	}repeat pop pop pop
}__NXbdef
/flushgraphics{}def
/setwindowtype{pop pop}def
/currentwindowtype{pop 0}def
/setalpha{pop}def
/currentalpha{1.0}def
/hidecursor{}def
/obscurecursor{}def
/revealcursor{}def
/setcursor{4 {pop}repeat}bind def
/showcursor{}def
/NextStepEncoding where not{
/NextStepEncoding StandardEncoding 256 array copy def
0 [129/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/Ccedilla/Egrave
/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/Ugrave/Uacute
/Ucircumflex/Udieresis/Yacute/Thorn/mu/multiply/divide/copyright
176/registered 181/brokenbar 190/logicalnot 192/onesuperior 201/twosuperior
204/threesuperior 209/plusminus/onequarter/onehalf/threequarters/agrave
/aacute/acircumflex/atilde/adieresis/aring/ccedilla/egrave/eacute
/ecircumflex/edieresis/igrave 226/iacute 228/icircumflex/idieresis/eth
/ntilde 236/ograve/oacute/ocircumflex/otilde/odieresis 242/ugrave/uacute
/ucircumflex 246/udieresis/yacute 252/thorn/ydieresis]
{dup type /nametype eq
 {NextStepEncoding 2 index 2 index put pop 1 add}{exch pop}ifelse
}forall pop
/NextStepEncoding NextStepEncoding readonly def
/_NXfstr 128 string dup 0 (_NX) putinterval def
/_NXfindfont /findfont load def
/findfont{
 % Because we can never let NextStepEncoding get into
 % SharedFontDirectory, we cannot reencode a font to NextStepEncoding
 % if we are in shared mode.  So if currentshared is true,
 % we call the normal findfont and return that
 /currentshared where {pop currentshared} {false} ifelse
 {_NXfindfont}
 {dup _NXfstr 3 125 getinterval cvs length 3 add _NXfstr 0 3 -1 roll
  getinterval cvn exch FontDirectory 2 index known 
  {pop FontDirectory exch get}
  {_NXfindfont dup /Encoding get StandardEncoding eq
   {	dup length dict exch
	{1 index /FID ne {2 index 3 1 roll put}{pop pop}ifelse}forall
	 dup /Encoding NextStepEncoding put definefont
	}{exch pop} ifelse
   }ifelse
 }ifelse
}bind def
}{pop}ifelse
/_NXImageString {/__NXImageString where{pop}{/__NXImageString 4000 string __NXdef}ifelse __NXImageString}__NXbdef
/_NXDoImageOp{
	3 dict begin /parr 5 array def 1 index{dup}{1}ifelse /chans exch def
	chans 2 add 2 roll parr 0 chans getinterval astore pop
	5 index 4 index mul 2 index{1 sub 8 idiv 1 add mul}{mul 1 sub 8 idiv 1 add}ifelse
	4 index mul /totbytes exch def pop exch pop
	gsave matrix invertmatrix concat 0.5 setgray 0 0 4 2 roll rectfill grestore
	{0 1 chans 1 sub{parr exch get exec length totbytes exch sub /totbytes exch def}for totbytes 0 le{exit}if}loop end
}__NXbdef
/alphaimage{1 add _NXDoImageOp}def
_NXLevel2{ 
	/NXCalibratedRGBColorSpace where{pop}{
		/NXCalibratedRGBColorSpace
		{mark /NXCalibratedRGB /ColorSpace findresource exch pop}stopped
		{cleartomark /NXCalibratedRGB[/CIEBasedABC 2 dict dup begin 
		/MatrixLMN[.4124 .2126 .0193 .3576 .7152 .1192 .1805 .0722 .9505]def
		/WhitePoint[.9505 1 1.089] def end] /ColorSpace defineresource}if def}ifelse
	/nxsetrgbcolor{NXCalibratedRGBColorSpace setcolorspace setcolor}__NXbdef
	/nxsetgray{dup dup nxsetrgbcolor}__NXbdef
	/_NXCalibratedImage{exch{array astore dup length true}{false}ifelse
		8 -1 roll{NXCalibratedRGBColorSpace setcolorspace}if
		8 dict dup 9 1 roll begin /ImageType 1 def /MultipleDataSources exch def
		currentcolorspace 0 get /Indexed eq{pop /Decode[0 2 6 index exp 1 sub]def}
		{2 mul dup array /Decode exch def 1 sub 0 1 3 -1 roll{Decode exch dup 2 mod put}for}ifelse
		/DataSource exch def /ImageMatrix exch def 
		/BitsPerComponent exch def /Height exch def /Width exch def end image}__NXbdef
} {
	/setcmykcolor{
		1.0 exch sub dup dup 6 -1 roll sub dup 0 lt{pop 0}if 5 1 roll
		4 -1 roll sub dup 0 lt{pop 0}if 3 1 roll exch sub dup 0 lt{pop 0}if setrgbcolor}__NXbdef
	/currentcmykcolor{currentrgbcolor 3{1.0 exch sub 3 1 roll}repeat 0}__NXbdef
	/colorimage{2 copy 3 ne or{_NXDoImageOp}{4 index dup 8 ne exch 4 ne and{_NXDoImageOp}{
		pop pop save 6 1 roll 12 dict begin/Proc exch def/Res 0 string def
		/Alloc{2 index length mul 2 add dup 2 index load length gt{1.2 mul round cvi string def}{pop pop}ifelse}def
		1 index 8 eq{/Unpack{.34 Alloc}def}{
			/Wid 4 index 3 mul def exch pop 8 exch/Str1 0 string def/Lim Wid def
			/Unpack{.67 Alloc/Str1 2 Alloc 0 exch Lim exch
				{dup -4 bitshift 17 mul Str1 exch 4 index exch put 15 and 17 mul Str1 exch 3 index 1 add exch put
				2 sub dup 0 le{0 lt Wid exch{exch 1 sub exch}if}if exch 2 add exch
				}forall/Lim exch def Str1 exch 0 exch getinterval
			}def
		}ifelse
		/Ops[{.3 mul add 1}{.59 mul add 2}{.11 mul add round cvi Res exch 2 index exch put 1 add 0.0 0}]def/Val 0.0 def/Phase 0 def
		{0 Val Phase Proc/Res Unpack{exch Ops exch get exec}forall/Phase exch def/Val exch def Res exch 0 exch getinterval}
		image end restore}ifelse}ifelse
	}__NXbdef
	/nxsetrgbcolor{setrgbcolor}__NXbdef /nxsetgray{setgray}__NXbdef
	/setpattern{pop .5 setgray}__NXbdef
	/_NXCalibratedImage{dup 1 eq {pop pop image}{colorimage}ifelse pop}__NXbdef
} ifelse
/_NXSetCMYKOrRGB where{pop}{
	mark{systemdict /currentwindow get exec}stopped
	{{pop pop pop setcmykcolor}}{{nxsetrgbcolor pop pop pop pop}}ifelse /_NXSetCMYKOrRGB exch def cleartomark
}ifelse
%%EndProcSet

/oval {
    translate scale newpath 0.5 0.5 0.5 0 360 arc closepath
} def /line {
    moveto rlineto stroke
} def /setup {
    setlinewidth setlinecap setlinejoin gsave
} def /arrow {
    newpath moveto dup rotate -13 6 rlineto 4 -6 rlineto -4 -6 rlineto closepath gsave 0 setlinejoin stroke grestore fill neg rotate
} def
gsave
 /__NXbasematrix matrix currentmatrix def
grestore
%%EndProlog
%%BeginSetup
%%EndSetup
gsave
0 0 309 668 rectclip
gsave
0 0 0 setup
0 nxsetgray
50 0 50 602 line
grestore
0 0 0 setup
0 nxsetgray
73 1 131 600 line
grestore
0 0 0 setup
0 nxsetgray
54 0 233 601 line
grestore
0 0 1.046512 setup
0 nxsetgray
1 -93 168 659 line
90.613426 168 659 arrow
grestore
0 0 1.046512 setup
0 nxsetgray
253 0 47 597 line
0 300 597 arrow
grestore
0 0 0 setup
98.000000 599.000000 transform
gsave __NXbasematrix setmatrix itransform translate
0 0 34 29 rectclip
gsave
-52 -78 translate

/__NXEPSSave save def /showpage {} def
_NXLevel2{/_NXsethsb where{pop}{/_NXsethsb /sethsbcolor load def}ifelse /sethsbcolor{_NXsethsb currentrgbcolor nxsetrgbcolor}def /setrgbcolor{nxsetrgbcolor}bind def /setgray{nxsetgray}bind def
/_NXcimage where{pop}{/_NXcimage /colorimage load def}ifelse /colorimage{dup 3 eq{true 2 index{1 index}{1}ifelse 7 add 1 roll _NXCalibratedImage}{_NXcimage}ifelse}def}if
0 setgray 0 setlinecap 1 setlinewidth
0 setlinejoin 10 setmiterlimit [] 0 setdash newpath count /__NXEPSOpCount exch def /__NXEPSDictCount countdictstack def
%%BeginDocument: 
%!PS-Adobe-2.0 EPSF-2.0
%%Title: Pencil - untitled
%%Creator: PencilTWO
%%CreationDate: Tue Oct 20 12:39:19 1998
%%For: rodolfo
%%DocumentFonts: (atend)
%%Pages: 0 0
%%BoundingBox: 52 78 86 107
%%NXNextStepVersion: 3.0
%%EndComments

%%BeginProcSet: /usr/lib/NextStep/printPackage.ps 3.0
%!
% NeXT Printing Package
% Version: 3.1
% Copyright: 1988, NeXT, Inc.

/__NXdef{1 index where{pop pop pop}{def}ifelse}bind def
/__NXbdef{1 index where{pop pop pop}{bind def}ifelse}bind def
/UserObjects 10 array __NXdef
/defineuserobject{
	exch dup 1 add dup UserObjects length gt{
		array dup 0 UserObjects putinterval
		/UserObjects exch def
	}{pop}ifelse UserObjects exch 3 -1 roll put
}__NXbdef
/undefineuserobject{UserObjects exch null put}__NXbdef
/execuserobject{UserObjects exch get exec}__NXbdef
/__NXRectPath{4 2 roll moveto 1 index 0 rlineto
0 exch rlineto neg 0 rlineto closepath}__NXbdef
/__NXProcessRectArgs{
	1 index type /arraytype eq{
		exch 0 4 2 index length 1 sub{
			dup 3 add 1 exch{1 index exch get exch}for
			5 1 roll 5 index exec
		}for pop pop
	}{exec}ifelse
}__NXbdef
/rectfill{gsave newpath {__NXRectPath fill} __NXProcessRectArgs grestore}__NXbdef
/rectclip{newpath {__NXRectPath} __NXProcessRectArgs clip newpath}__NXbdef
/rectstroke{
	gsave newpath dup type /arraytype eq{dup length 6 eq}{false}ifelse{
		{gsave __NXRectPath null concat stroke grestore}
		dup length array cvx copy dup 2 4 -1 roll put __NXProcessRectArgs
	}{{__NXRectPath stroke} __NXProcessRectArgs}ifelse grestore
}__NXbdef
/_NXLevel2 systemdict /languagelevel known {languagelevel 2 ge}{false}ifelse __NXdef
/xyshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index 2 mul 1 add get add exch
		3 index	3 index 2 mul get add exch moveto pop
	}for pop pop
}__NXbdef
/xshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		exch 3 index 3 index get add exch moveto pop
	}for pop pop
}__NXbdef
/yshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index get add moveto pop
	}for pop pop
}__NXbdef
/arct{arcto pop pop pop pop}__NXbdef
/setbbox{pop pop pop pop}__NXbdef
/ucache{}__NXbdef
/ucachestatus{mark 0 0 0 0 0}__NXbdef
/setucacheparams{cleartomark}__NXbdef
/uappend{systemdict begin cvx exec end}__NXbdef
/ueofill{gsave newpath uappend eofill grestore}__NXbdef
/ufill{gsave newpath uappend fill grestore}__NXbdef
/ustroke{
	gsave newpath dup length 6 eq
	{exch uappend concat}{uappend}ifelse
	stroke grestore
}__NXbdef
/__NXustrokepathMatrix dup where {pop pop}{matrix def}ifelse
/ustrokepath{
	newpath dup length 6 eq{
		exch uappend __NXustrokepathMatrix currentmatrix exch concat
		strokepath setmatrix
	}{uappend strokepath}ifelse
} __NXbdef
/upath{
	[exch {/ucache cvx}if pathbbox /setbbox cvx
	 {/moveto cvx}{/lineto cvx}{/curveto cvx}{/closepath cvx}pathforall]cvx
} __NXbdef
/setstrokeadjust{pop}__NXbdef
/currentstrokeadjust{false}__NXbdef
/selectfont{exch findfont exch
dup type /arraytype eq {makefont}{scalefont}ifelse setfont}__NXbdef
/_NXCombineArrays{
	counttomark dup 2 add index dup length 3 -1 roll {
		2 index length sub dup 4 1 roll 1 index exch 4 -1 roll putinterval exch
	}repeat pop pop pop
}__NXbdef
/flushgraphics{}def
/setwindowtype{pop pop}def
/currentwindowtype{pop 0}def
/setalpha{pop}def
/currentalpha{1.0}def
/hidecursor{}def
/obscurecursor{}def
/revealcursor{}def
/setcursor{4 {pop}repeat}bind def
/showcursor{}def
/NextStepEncoding where not{
/NextStepEncoding StandardEncoding 256 array copy def
0 [129/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/Ccedilla/Egrave
/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/Ugrave/Uacute
/Ucircumflex/Udieresis/Yacute/Thorn/mu/multiply/divide/copyright
176/registered 181/brokenbar 190/logicalnot 192/onesuperior 201/twosuperior
204/threesuperior 209/plusminus/onequarter/onehalf/threequarters/agrave
/aacute/acircumflex/atilde/adieresis/aring/ccedilla/egrave/eacute
/ecircumflex/edieresis/igrave 226/iacute 228/icircumflex/idieresis/eth
/ntilde 236/ograve/oacute/ocircumflex/otilde/odieresis 242/ugrave/uacute
/ucircumflex 246/udieresis/yacute 252/thorn/ydieresis]
{dup type /nametype eq
 {NextStepEncoding 2 index 2 index put pop 1 add}{exch pop}ifelse
}forall pop
/NextStepEncoding NextStepEncoding readonly def
/_NXfstr 128 string dup 0 (_NX) putinterval def
/_NXfindfont /findfont load def
/findfont{
 % Because we can never let NextStepEncoding get into
 % SharedFontDirectory, we cannot reencode a font to NextStepEncoding
 % if we are in shared mode.  So if currentshared is true,
 % we call the normal findfont and return that
 /currentshared where {pop currentshared} {false} ifelse
 {_NXfindfont}
 {dup _NXfstr 3 125 getinterval cvs length 3 add _NXfstr 0 3 -1 roll
  getinterval cvn exch FontDirectory 2 index known 
  {pop FontDirectory exch get}
  {_NXfindfont dup /Encoding get StandardEncoding eq
   {	dup length dict exch
	{1 index /FID ne {2 index 3 1 roll put}{pop pop}ifelse}forall
	 dup /Encoding NextStepEncoding put definefont
	}{exch pop} ifelse
   }ifelse
 }ifelse
}bind def
}{pop}ifelse
/_NXImageString {/__NXImageString where{pop}{/__NXImageString 4000 string __NXdef}ifelse __NXImageString}__NXbdef
/_NXDoImageOp{
	3 dict begin /parr 5 array def 1 index{dup}{1}ifelse /chans exch def
	chans 2 add 2 roll parr 0 chans getinterval astore pop
	5 index 4 index mul 2 index{1 sub 8 idiv 1 add mul}{mul 1 sub 8 idiv 1 add}ifelse
	4 index mul /totbytes exch def pop exch pop
	gsave matrix invertmatrix concat 0.5 setgray 0 0 4 2 roll rectfill grestore
	{0 1 chans 1 sub{parr exch get exec length totbytes exch sub /totbytes exch def}for totbytes 0 le{exit}if}loop end
}__NXbdef
/alphaimage{1 add _NXDoImageOp}def
_NXLevel2{ 
	/NXCalibratedRGBColorSpace where{pop}{
		/NXCalibratedRGBColorSpace
		{mark /NXCalibratedRGB /ColorSpace findresource exch pop}stopped
		{cleartomark /NXCalibratedRGB[/CIEBasedABC 2 dict dup begin 
		/MatrixLMN[.4124 .2126 .0193 .3576 .7152 .1192 .1805 .0722 .9505]def
		/WhitePoint[.9505 1 1.089] def end] /ColorSpace defineresource}if def}ifelse
	/nxsetrgbcolor{NXCalibratedRGBColorSpace setcolorspace setcolor}__NXbdef
	/nxsetgray{dup dup nxsetrgbcolor}__NXbdef
	/_NXCalibratedImage{exch{array astore dup length true}{false}ifelse
		8 -1 roll{NXCalibratedRGBColorSpace setcolorspace}if
		8 dict dup 9 1 roll begin /ImageType 1 def /MultipleDataSources exch def
		currentcolorspace 0 get /Indexed eq{pop /Decode[0 2 6 index exp 1 sub]def}
		{2 mul dup array /Decode exch def 1 sub 0 1 3 -1 roll{Decode exch dup 2 mod put}for}ifelse
		/DataSource exch def /ImageMatrix exch def 
		/BitsPerComponent exch def /Height exch def /Width exch def end image}__NXbdef
} {
	/setcmykcolor{
		1.0 exch sub dup dup 6 -1 roll sub dup 0 lt{pop 0}if 5 1 roll
		4 -1 roll sub dup 0 lt{pop 0}if 3 1 roll exch sub dup 0 lt{pop 0}if setrgbcolor}__NXbdef
	/currentcmykcolor{currentrgbcolor 3{1.0 exch sub 3 1 roll}repeat 0}__NXbdef
	/colorimage{2 copy 3 ne or{_NXDoImageOp}{4 index dup 8 ne exch 4 ne and{_NXDoImageOp}{
		pop pop save 6 1 roll 12 dict begin/Proc exch def/Res 0 string def
		/Alloc{2 index length mul 2 add dup 2 index load length gt{1.2 mul round cvi string def}{pop pop}ifelse}def
		1 index 8 eq{/Unpack{.34 Alloc}def}{
			/Wid 4 index 3 mul def exch pop 8 exch/Str1 0 string def/Lim Wid def
			/Unpack{.67 Alloc/Str1 2 Alloc 0 exch Lim exch
				{dup -4 bitshift 17 mul Str1 exch 4 index exch put 15 and 17 mul Str1 exch 3 index 1 add exch put
				2 sub dup 0 le{0 lt Wid exch{exch 1 sub exch}if}if exch 2 add exch
				}forall/Lim exch def Str1 exch 0 exch getinterval
			}def
		}ifelse
		/Ops[{.3 mul add 1}{.59 mul add 2}{.11 mul add round cvi Res exch 2 index exch put 1 add 0.0 0}]def/Val 0.0 def/Phase 0 def
		{0 Val Phase Proc/Res Unpack{exch Ops exch get exec}forall/Phase exch def/Val exch def Res exch 0 exch getinterval}
		image end restore}ifelse}ifelse
	}__NXbdef
	/nxsetrgbcolor{setrgbcolor}__NXbdef /nxsetgray{setgray}__NXbdef
	/setpattern{pop .5 setgray}__NXbdef
	/_NXCalibratedImage{dup 1 eq {pop pop image}{colorimage}ifelse pop}__NXbdef
} ifelse
/_NXSetCMYKOrRGB where{pop}{
	mark{systemdict /currentwindow get exec}stopped
	{{pop pop pop setcmykcolor}}{{nxsetrgbcolor pop pop pop pop}}ifelse /_NXSetCMYKOrRGB exch def cleartomark
}ifelse
%%EndProcSet

gsave
-21 -51 translate
 /__NXbasematrix matrix currentmatrix def
grestore
%%EndProlog
%%BeginSetup
%%EndSetup
gsave
0 0 515 762 rectclip
52.5 78.5 33 28 rectclip

% PENCIL printing Package BASIC
/fbb {
gsave
initmatrix
newpath cp
pathbbox
grestore
} def
/fsbb {
fbb /x1 exch def /x2 exch def /y1 exch def /y2 exch def
/linw linw 1 add def
y2 linw sub y1 linw sub x2 linw add x1 linw add
} def
/enlbb {
/dy exch def /dx exch def /y exch def /x exch def
/y1 exch def /x1 exch def /y2 exch def /x2 exch def
x2 x add y2 y add x1 dx add y1 dy add
} def

/cir {
	nctrl 2 ge {
		/x ctrl 0 get def
		/y ctrl 1 get def
		nctrl 3 ge {
		matrix currentmatrix
		x y translate
		1 ctrl 5 get y sub ctrl 2 get x sub div scale 
		0 0
		ctrl 2 get x sub
		0 360 arc closepath
		setmatrix
		} {
		x y
		ctrl 2 get x sub 2 exp
		ctrl 3 get y sub 2 exp add sqrt
		0 360 arc closepath } ifelse
		} {
 		nctrl 1 eq {
		ctrl 0 get
		ctrl 1 get
		20
		0 360 arc closepath
		} {
		0 0 moveto
		} ifelse
	} ifelse
} def

/charP {
	/font (Helvetica) def
	/fontsize 24 def
	/text () def
	udt
	nctrl 1 ge {
	ctrl 0 get ctrl 1 get moveto
	font findfont fontsize scalefont setfont
	text false charpath
	} if
} def

/her {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 div cvi 2 sub { /i exch 4 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get 2 mul ctrl i 6 add get sub ctrl i 5 add get 2 mul ctrl i 7 add get sub
ctrl i 4 add get ctrl i 5 add get curveto
} for
ctrl nctrl 1 sub 2 mul get ctrl nctrl 1 sub 2 mul 1 add get
ctrl 0 get 2 mul ctrl 2 get sub ctrl 1 get 2 mul ctrl 3 get sub
ctrl 0 get ctrl 1 get curveto
closepath
} { 0 0 moveto } ifelse
} def

/herO {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 div cvi 2 sub { /i exch 4 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get 2 mul ctrl i 6 add get sub ctrl i 5 add get 2 mul ctrl i 7 add get sub
ctrl i 4 add get ctrl i 5 add get curveto
} for
} { 0 0 moveto } ifelse
} def

/cat {
nctrl 2 ge {
/xyA [0 0
1 1 nctrl 2 sub { /i exch 2 mul def
/dx ctrl i 2 add get ctrl i 2 sub get sub def
/dy ctrl i 3 add get ctrl i 1 sub get sub def
/l dx 2 exp dy 2 exp add sqrt def
dx l div dy l div
} for
0 0] def
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 sub { /i exch 2 mul def
/l
ctrl i 2 add get /x ctrl i get def x sub 2 exp
ctrl i 3 add get /y ctrl i 1 add get def y sub 2 exp add sqrt .5 mul
def
x xyA i get l mul add
y xyA i 1 add get l mul add
/x ctrl i 2 add get def
/y ctrl i 3 add get def
x xyA i 2 add get l mul sub
y xyA i 3 add get l mul sub
x y curveto
} for
} {
0 0 moveto
} ifelse
} def

/bez {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 add 3 div cvi 2 sub { /i exch 6 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get ctrl i 5 add get
ctrl i 6 add get ctrl i 7 add get curveto
} for
/i nctrl 3 sub 3 div cvi 3 mul def
i nctrl 3 sub eq {
/i i 1 add 2 mul def
ctrl i get ctrl i 1 add get
ctrl i 2 add get ctrl i 3 add get
ctrl 0 get ctrl 1 get curveto
} if
closepath
} { 0 0 moveto } ifelse
} def

/bezO {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 add 3 div cvi 2 sub { /i exch 6 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get ctrl i 5 add get
ctrl i 6 add get ctrl i 7 add get curveto
} for
} { 0 0 moveto } ifelse
} def

/rect {
	nctrl 2 ge {
		/x1 ctrl 0 get def /y1 ctrl 1 get def /x2 ctrl 2 get def /y2 ctrl 3 get def
		x1 y1 moveto x2 y1 lineto x2 y2 lineto x1 y2 lineto closepath
	} { 0 0 moveto } ifelse
} def

/pol {
	nctrl 2 ge {
		ctrl 0 get ctrl 1 get moveto
		1 1 nctrl 1 sub { /i exch 2 mul def
		ctrl i get ctrl i 1 add get lineto } for
		closepath
	} { 0 0 moveto } ifelse
	/D 1 def
} def

/polO {
	nctrl 2 ge {
		ctrl 0 get ctrl 1 get moveto
		1 1 nctrl 1 sub { /i exch 2 mul def
		ctrl i get ctrl i 1 add get lineto } for
	} { 0 0 moveto } ifelse
} def

/arcP {
	nctrl 3 ge {
		/x ctrl 0 get def /y ctrl 1 get def
		x y moveto
		x y
		/x1 ctrl 2 get x sub def
		/y1 ctrl 3 get y sub def
		/x2 ctrl 4 get x sub def
		/y2 ctrl 5 get y sub def
		x1 2 exp y1 2 exp add sqrt
		y1 x1 atan
		y2 x2 atan
		arc closepath
	} { 0 0 moveto } ifelse
} def

/arcPO {
	nctrl 3 ge {
		/x ctrl 0 get def /y ctrl 1 get def
		x y
		/x1 ctrl 2 get x sub def
		/y1 ctrl 3 get y sub def
		/x2 ctrl 4 get x sub def
		/y2 ctrl 5 get y sub def
		x1 2 exp y1 2 exp add sqrt
		y1 x1 atan
		y2 x2 atan
		arc
	} { 0 0 moveto } ifelse
} def

/rrect {
	/ci 10 def
	udt
	nctrl 2 ge {
	/x1 ctrl 0 get def /y1 ctrl 1 get def /x2 ctrl 2 get def /y2 ctrl 3 get def
	x2 ci sub y1 ci add ci -90 0 arc
	x2 ci sub y2 ci sub ci 0 90 arc
	x1 ci add y2 ci sub ci 90 180 arc
	x1 ci add y1 ci add ci 180 270 arc closepath
	} { 0 0 moveto } ifelse
} def

/dFS {
	cl setrgbcolor
	cp
	gsave
	cfl
	grestore
	setrgbcolor
	cst
} def
/dFSBB { fsbb } def

/dS {
	cl pop pop pop setrgbcolor
	cp
	cst
} def
/dSBB { fsbb } def

/dF {
	cl setrgbcolor
	cp
	cfl
	pop pop pop
} def
/dFBB { fbb } def

/dSF {
cl 6 3 roll setrgbcolor
cp gsave cst grestore
setrgbcolor cfl
} def
/dSFBB { fsbb } def

/dsh {
	/dpt [5 5] def
	udt
	dpt 0 setdash
	stroke
	[] 0 setdash
} def

/dbl {
	gsave currentlinewidth 2 mul setlinewidth stroke grestore
	1 setgray stroke
} def

/qual 1 def

/SET {
/i exch def
i length 1 sub -1 0 {
i exch get exch def
} for
} def

/doClip {
gsave newpath
initmatrix cp pathbbox grestore
[/x1 /y1 /x2 /y2] SET
gsave
clip newpath
x1 y1 translate
/width x2 x1 sub def
/height y2 y1 sub def
} def

/endClip {
grestore
newpath
} def

/grid {
/st 5 def
udt
doClip
0 st height { 0 exch moveto width 0 rlineto stroke
} for
0 st width { 0 moveto 0 height rlineto stroke } for
endClip
} def

/hrL {
/st 5 def
udt
doClip
0 st height { 0 exch moveto width 0 rlineto stroke
} for
endClip
} def

/vrL {
/st 5 def
udt
doClip
0 st width { 0 moveto 0 height rlineto stroke } for
endClip
} def

% END PENCIL printing Package

% PENCIL printing Package EXTRAS

/dFSSh {
	/shadowgray .2 def
	gsave
	5 -5 translate
	udt shadowgray setgray /shadowgray .2 def
	cp
	fill
	grestore
	cl setrgbcolor
	cp
	gsave
	cfl
	grestore
	setrgbcolor
	cst
} def
/dFSShBB { fsbb 0 -5 5 0 enlbb } def

/dSSh {
	gsave
	5 -5 translate
	/shadowgray .2 def udt shadowgray setgray 
	cp
	cst
	grestore
	cl pop pop pop setrgbcolor
	cp
	cst
} def
/dSShBB { fsbb 0 -5 5 0 enlbb } def

/dFSh {
	gsave
	5 -5 translate
	/shadowgray .2 def udt shadowgray setgray
	cp
	fill
	grestore
	cl setrgbcolor pop pop pop
	cp
	cfl
} def
/dFShBB { fbb 0 -5 5 0 enlbb } def

/d3D {
	cl setrgbcolor pop pop pop
	gsave
	-2 2 translate
	currenthsbcolor pop pop .5 1 sethsbcolor
	cp fill
	grestore
	gsave
	2 -2 translate
	currenthsbcolor pop .2 sethsbcolor
	cp fill
	grestore
	cp cfl
} def
/d3DBB { fsbb } def

/d3DSh {
	cl setrgbcolor
	gsave
	5 -5 translate
	.3 setgray
	cp fill
	grestore
	gsave
	-2 2 translate
	currenthsbcolor pop pop .5 1 sethsbcolor
	cp fill
	grestore
	gsave
	2 -2 translate
	currenthsbcolor pop .2 sethsbcolor
	cp fill
	grestore
	cp cfl
} def
/d3DShBB { fsbb 0 -5 5 0 enlbb } def

/grad {
/phi 0 def
udt
cl [/r1 /g1 /b1 /r2 /g2 /b2] SET
/r2 r2 r1 sub def
/g2 g2 g1 sub def
/b2 b2 b1 sub def
gsave newpath initmatrix cp pathbbox grestore
[/x1 /y1 /x2 /y2] SET
gsave
clip
newpath
x1 y1 translate
/x x2 x1 sub def
/y y2 y1 sub .1 add def
phi 0 ne { phi neg rotate } if
y phi sin mul neg 0 translate
/l y phi sin mul x phi cos mul add def
dg {
0 1 y phi cos mul x phi sin mul add qual div .5 add div 2 mul 1.01 { /i exch def
r1 i r2 mul add g1 i g2 mul add b1 i b2 mul add setrgbcolor
0 0 l qual rectfill 0 qual translate
} for
0 1 y phi cos mul x phi sin mul add qual div .5 add div 2 mul 1.01 { /i exch 1 sub neg def
r1 i r2 mul add g1 i g2 mul add b1 i b2 mul add setrgbcolor
0 0 l qual rectfill 0 qual translate
} for
} {
0 1 y phi cos mul x phi sin mul add qual div .5 add div 1.01 { /i exch def
r1 i r2 mul add g1 i g2 mul add b1 i b2 mul add setrgbcolor
0 0 l qual rectfill 0 qual translate
} for
} ifelse
grestore
newpath
} def

/grd { /dg false def grad } def
/dgrd { /dg true def grad } def

/sphGrad {
/centerR .2 def
/centerX .4 def
cl [/r1 /g1 /b1 /r2 /g2 /b2] SET
/b2 b2 b1 sub def
/g2 g2 g1 sub def
/r2 r2 r1 sub def
udt
gsave newpath initmatrix cp pathbbox grestore
[/x1 /y1 /x2 /y2] SET
gsave
clip
x1 x2 add 2 div y1 y2 add 2 div translate
/dy x2 x1 sub 2 div def
/l dy 1 centerR sub mul qual div cvi 5 add def
/dx centerR 1 l div exp def
/st centerX dy mul dx div 1 dx sub mul 1 dx l exp sub div def
0 1 l {
/i exch l div def
r1 r2 i mul add
g1 g2 i mul add
b1 b2 i mul add
setrgbcolor
0 0 dy 0 360 arc fill
st neg  st translate
dx dup scale
} for
grestore
newpath
} def

/gstroke {
/l currentlinewidth def
cl [/r1 /g1 /b1 /r2 /g2 /b2] SET
/r1 r1 r2 sub def
/g1 g1 g2 sub def
/b1 b1 b2 sub def
1 -.1 0 { /i exch def
i l mul setlinewidth
r2 r1 i mul add g2 g1 i mul add b2 b1 i mul add setrgbcolor
gsave stroke grestore
} for
newpath
} def
% END of EXTRAS

% PENCIL EFFECTS1
/hair {
	/l currentlinewidth def
	/st 1 def
	udt
	/i 1 def
	l st neg 0 { 
	i setgray
	setlinewidth
	gsave stroke grestore
	/i 1 i sub def
	} for
	newpath
} def
% END EFFECTS1


/qual 1 def

1 setgray
52.5 78.5 33 28 rectclip
52.5 78.5 33 28 rectfill
gsave
-24 -13 translate
 /udt {  } def  /ctrl [78 93 80 118 106 117 108 93]
 def 0 setlinewidth 0 setgray /nctrl 4 def bezO stroke
grestore
grestore
%%Trailer

%%EndDocument
count __NXEPSOpCount sub {pop} repeat countdictstack __NXEPSDictCount sub {end} repeat __NXEPSSave restore
grestore
grestore
grestore
0 0 0 setup
201.000000 599.000000 transform
gsave __NXbasematrix setmatrix itransform translate
0 0 34 29 rectclip
gsave
-52 -78 translate

/__NXEPSSave save def /showpage {} def
_NXLevel2{/_NXsethsb where{pop}{/_NXsethsb /sethsbcolor load def}ifelse /sethsbcolor{_NXsethsb currentrgbcolor nxsetrgbcolor}def /setrgbcolor{nxsetrgbcolor}bind def /setgray{nxsetgray}bind def
/_NXcimage where{pop}{/_NXcimage /colorimage load def}ifelse /colorimage{dup 3 eq{true 2 index{1 index}{1}ifelse 7 add 1 roll _NXCalibratedImage}{_NXcimage}ifelse}def}if
0 setgray 0 setlinecap 1 setlinewidth
0 setlinejoin 10 setmiterlimit [] 0 setdash newpath count /__NXEPSOpCount exch def /__NXEPSDictCount countdictstack def
%%BeginDocument: 
%!PS-Adobe-2.0 EPSF-2.0
%%Title: Pencil - untitled
%%Creator: PencilTWO
%%CreationDate: Tue Oct 20 12:39:19 1998
%%For: rodolfo
%%DocumentFonts: (atend)
%%Pages: 0 0
%%BoundingBox: 52 78 86 107
%%NXNextStepVersion: 3.0
%%EndComments

%%BeginProcSet: /usr/lib/NextStep/printPackage.ps 3.0
%!
% NeXT Printing Package
% Version: 3.1
% Copyright: 1988, NeXT, Inc.

/__NXdef{1 index where{pop pop pop}{def}ifelse}bind def
/__NXbdef{1 index where{pop pop pop}{bind def}ifelse}bind def
/UserObjects 10 array __NXdef
/defineuserobject{
	exch dup 1 add dup UserObjects length gt{
		array dup 0 UserObjects putinterval
		/UserObjects exch def
	}{pop}ifelse UserObjects exch 3 -1 roll put
}__NXbdef
/undefineuserobject{UserObjects exch null put}__NXbdef
/execuserobject{UserObjects exch get exec}__NXbdef
/__NXRectPath{4 2 roll moveto 1 index 0 rlineto
0 exch rlineto neg 0 rlineto closepath}__NXbdef
/__NXProcessRectArgs{
	1 index type /arraytype eq{
		exch 0 4 2 index length 1 sub{
			dup 3 add 1 exch{1 index exch get exch}for
			5 1 roll 5 index exec
		}for pop pop
	}{exec}ifelse
}__NXbdef
/rectfill{gsave newpath {__NXRectPath fill} __NXProcessRectArgs grestore}__NXbdef
/rectclip{newpath {__NXRectPath} __NXProcessRectArgs clip newpath}__NXbdef
/rectstroke{
	gsave newpath dup type /arraytype eq{dup length 6 eq}{false}ifelse{
		{gsave __NXRectPath null concat stroke grestore}
		dup length array cvx copy dup 2 4 -1 roll put __NXProcessRectArgs
	}{{__NXRectPath stroke} __NXProcessRectArgs}ifelse grestore
}__NXbdef
/_NXLevel2 systemdict /languagelevel known {languagelevel 2 ge}{false}ifelse __NXdef
/xyshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index 2 mul 1 add get add exch
		3 index	3 index 2 mul get add exch moveto pop
	}for pop pop
}__NXbdef
/xshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		exch 3 index 3 index get add exch moveto pop
	}for pop pop
}__NXbdef
/yshow{
	0 1 3 index length 1 sub{
		currentpoint 4 index 3 index 1 getinterval show
		3 index 3 index get add moveto pop
	}for pop pop
}__NXbdef
/arct{arcto pop pop pop pop}__NXbdef
/setbbox{pop pop pop pop}__NXbdef
/ucache{}__NXbdef
/ucachestatus{mark 0 0 0 0 0}__NXbdef
/setucacheparams{cleartomark}__NXbdef
/uappend{systemdict begin cvx exec end}__NXbdef
/ueofill{gsave newpath uappend eofill grestore}__NXbdef
/ufill{gsave newpath uappend fill grestore}__NXbdef
/ustroke{
	gsave newpath dup length 6 eq
	{exch uappend concat}{uappend}ifelse
	stroke grestore
}__NXbdef
/__NXustrokepathMatrix dup where {pop pop}{matrix def}ifelse
/ustrokepath{
	newpath dup length 6 eq{
		exch uappend __NXustrokepathMatrix currentmatrix exch concat
		strokepath setmatrix
	}{uappend strokepath}ifelse
} __NXbdef
/upath{
	[exch {/ucache cvx}if pathbbox /setbbox cvx
	 {/moveto cvx}{/lineto cvx}{/curveto cvx}{/closepath cvx}pathforall]cvx
} __NXbdef
/setstrokeadjust{pop}__NXbdef
/currentstrokeadjust{false}__NXbdef
/selectfont{exch findfont exch
dup type /arraytype eq {makefont}{scalefont}ifelse setfont}__NXbdef
/_NXCombineArrays{
	counttomark dup 2 add index dup length 3 -1 roll {
		2 index length sub dup 4 1 roll 1 index exch 4 -1 roll putinterval exch
	}repeat pop pop pop
}__NXbdef
/flushgraphics{}def
/setwindowtype{pop pop}def
/currentwindowtype{pop 0}def
/setalpha{pop}def
/currentalpha{1.0}def
/hidecursor{}def
/obscurecursor{}def
/revealcursor{}def
/setcursor{4 {pop}repeat}bind def
/showcursor{}def
/NextStepEncoding where not{
/NextStepEncoding StandardEncoding 256 array copy def
0 [129/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/Ccedilla/Egrave
/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/Ugrave/Uacute
/Ucircumflex/Udieresis/Yacute/Thorn/mu/multiply/divide/copyright
176/registered 181/brokenbar 190/logicalnot 192/onesuperior 201/twosuperior
204/threesuperior 209/plusminus/onequarter/onehalf/threequarters/agrave
/aacute/acircumflex/atilde/adieresis/aring/ccedilla/egrave/eacute
/ecircumflex/edieresis/igrave 226/iacute 228/icircumflex/idieresis/eth
/ntilde 236/ograve/oacute/ocircumflex/otilde/odieresis 242/ugrave/uacute
/ucircumflex 246/udieresis/yacute 252/thorn/ydieresis]
{dup type /nametype eq
 {NextStepEncoding 2 index 2 index put pop 1 add}{exch pop}ifelse
}forall pop
/NextStepEncoding NextStepEncoding readonly def
/_NXfstr 128 string dup 0 (_NX) putinterval def
/_NXfindfont /findfont load def
/findfont{
 % Because we can never let NextStepEncoding get into
 % SharedFontDirectory, we cannot reencode a font to NextStepEncoding
 % if we are in shared mode.  So if currentshared is true,
 % we call the normal findfont and return that
 /currentshared where {pop currentshared} {false} ifelse
 {_NXfindfont}
 {dup _NXfstr 3 125 getinterval cvs length 3 add _NXfstr 0 3 -1 roll
  getinterval cvn exch FontDirectory 2 index known 
  {pop FontDirectory exch get}
  {_NXfindfont dup /Encoding get StandardEncoding eq
   {	dup length dict exch
	{1 index /FID ne {2 index 3 1 roll put}{pop pop}ifelse}forall
	 dup /Encoding NextStepEncoding put definefont
	}{exch pop} ifelse
   }ifelse
 }ifelse
}bind def
}{pop}ifelse
/_NXImageString {/__NXImageString where{pop}{/__NXImageString 4000 string __NXdef}ifelse __NXImageString}__NXbdef
/_NXDoImageOp{
	3 dict begin /parr 5 array def 1 index{dup}{1}ifelse /chans exch def
	chans 2 add 2 roll parr 0 chans getinterval astore pop
	5 index 4 index mul 2 index{1 sub 8 idiv 1 add mul}{mul 1 sub 8 idiv 1 add}ifelse
	4 index mul /totbytes exch def pop exch pop
	gsave matrix invertmatrix concat 0.5 setgray 0 0 4 2 roll rectfill grestore
	{0 1 chans 1 sub{parr exch get exec length totbytes exch sub /totbytes exch def}for totbytes 0 le{exit}if}loop end
}__NXbdef
/alphaimage{1 add _NXDoImageOp}def
_NXLevel2{ 
	/NXCalibratedRGBColorSpace where{pop}{
		/NXCalibratedRGBColorSpace
		{mark /NXCalibratedRGB /ColorSpace findresource exch pop}stopped
		{cleartomark /NXCalibratedRGB[/CIEBasedABC 2 dict dup begin 
		/MatrixLMN[.4124 .2126 .0193 .3576 .7152 .1192 .1805 .0722 .9505]def
		/WhitePoint[.9505 1 1.089] def end] /ColorSpace defineresource}if def}ifelse
	/nxsetrgbcolor{NXCalibratedRGBColorSpace setcolorspace setcolor}__NXbdef
	/nxsetgray{dup dup nxsetrgbcolor}__NXbdef
	/_NXCalibratedImage{exch{array astore dup length true}{false}ifelse
		8 -1 roll{NXCalibratedRGBColorSpace setcolorspace}if
		8 dict dup 9 1 roll begin /ImageType 1 def /MultipleDataSources exch def
		currentcolorspace 0 get /Indexed eq{pop /Decode[0 2 6 index exp 1 sub]def}
		{2 mul dup array /Decode exch def 1 sub 0 1 3 -1 roll{Decode exch dup 2 mod put}for}ifelse
		/DataSource exch def /ImageMatrix exch def 
		/BitsPerComponent exch def /Height exch def /Width exch def end image}__NXbdef
} {
	/setcmykcolor{
		1.0 exch sub dup dup 6 -1 roll sub dup 0 lt{pop 0}if 5 1 roll
		4 -1 roll sub dup 0 lt{pop 0}if 3 1 roll exch sub dup 0 lt{pop 0}if setrgbcolor}__NXbdef
	/currentcmykcolor{currentrgbcolor 3{1.0 exch sub 3 1 roll}repeat 0}__NXbdef
	/colorimage{2 copy 3 ne or{_NXDoImageOp}{4 index dup 8 ne exch 4 ne and{_NXDoImageOp}{
		pop pop save 6 1 roll 12 dict begin/Proc exch def/Res 0 string def
		/Alloc{2 index length mul 2 add dup 2 index load length gt{1.2 mul round cvi string def}{pop pop}ifelse}def
		1 index 8 eq{/Unpack{.34 Alloc}def}{
			/Wid 4 index 3 mul def exch pop 8 exch/Str1 0 string def/Lim Wid def
			/Unpack{.67 Alloc/Str1 2 Alloc 0 exch Lim exch
				{dup -4 bitshift 17 mul Str1 exch 4 index exch put 15 and 17 mul Str1 exch 3 index 1 add exch put
				2 sub dup 0 le{0 lt Wid exch{exch 1 sub exch}if}if exch 2 add exch
				}forall/Lim exch def Str1 exch 0 exch getinterval
			}def
		}ifelse
		/Ops[{.3 mul add 1}{.59 mul add 2}{.11 mul add round cvi Res exch 2 index exch put 1 add 0.0 0}]def/Val 0.0 def/Phase 0 def
		{0 Val Phase Proc/Res Unpack{exch Ops exch get exec}forall/Phase exch def/Val exch def Res exch 0 exch getinterval}
		image end restore}ifelse}ifelse
	}__NXbdef
	/nxsetrgbcolor{setrgbcolor}__NXbdef /nxsetgray{setgray}__NXbdef
	/setpattern{pop .5 setgray}__NXbdef
	/_NXCalibratedImage{dup 1 eq {pop pop image}{colorimage}ifelse pop}__NXbdef
} ifelse
/_NXSetCMYKOrRGB where{pop}{
	mark{systemdict /currentwindow get exec}stopped
	{{pop pop pop setcmykcolor}}{{nxsetrgbcolor pop pop pop pop}}ifelse /_NXSetCMYKOrRGB exch def cleartomark
}ifelse
%%EndProcSet

gsave
-21 -51 translate
 /__NXbasematrix matrix currentmatrix def
grestore
%%EndProlog
%%BeginSetup
%%EndSetup
gsave
0 0 515 762 rectclip
52.5 78.5 33 28 rectclip

% PENCIL printing Package BASIC
/fbb {
gsave
initmatrix
newpath cp
pathbbox
grestore
} def
/fsbb {
fbb /x1 exch def /x2 exch def /y1 exch def /y2 exch def
/linw linw 1 add def
y2 linw sub y1 linw sub x2 linw add x1 linw add
} def
/enlbb {
/dy exch def /dx exch def /y exch def /x exch def
/y1 exch def /x1 exch def /y2 exch def /x2 exch def
x2 x add y2 y add x1 dx add y1 dy add
} def

/cir {
	nctrl 2 ge {
		/x ctrl 0 get def
		/y ctrl 1 get def
		nctrl 3 ge {
		matrix currentmatrix
		x y translate
		1 ctrl 5 get y sub ctrl 2 get x sub div scale 
		0 0
		ctrl 2 get x sub
		0 360 arc closepath
		setmatrix
		} {
		x y
		ctrl 2 get x sub 2 exp
		ctrl 3 get y sub 2 exp add sqrt
		0 360 arc closepath } ifelse
		} {
 		nctrl 1 eq {
		ctrl 0 get
		ctrl 1 get
		20
		0 360 arc closepath
		} {
		0 0 moveto
		} ifelse
	} ifelse
} def

/charP {
	/font (Helvetica) def
	/fontsize 24 def
	/text () def
	udt
	nctrl 1 ge {
	ctrl 0 get ctrl 1 get moveto
	font findfont fontsize scalefont setfont
	text false charpath
	} if
} def

/her {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 div cvi 2 sub { /i exch 4 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get 2 mul ctrl i 6 add get sub ctrl i 5 add get 2 mul ctrl i 7 add get sub
ctrl i 4 add get ctrl i 5 add get curveto
} for
ctrl nctrl 1 sub 2 mul get ctrl nctrl 1 sub 2 mul 1 add get
ctrl 0 get 2 mul ctrl 2 get sub ctrl 1 get 2 mul ctrl 3 get sub
ctrl 0 get ctrl 1 get curveto
closepath
} { 0 0 moveto } ifelse
} def

/herO {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 div cvi 2 sub { /i exch 4 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get 2 mul ctrl i 6 add get sub ctrl i 5 add get 2 mul ctrl i 7 add get sub
ctrl i 4 add get ctrl i 5 add get curveto
} for
} { 0 0 moveto } ifelse
} def

/cat {
nctrl 2 ge {
/xyA [0 0
1 1 nctrl 2 sub { /i exch 2 mul def
/dx ctrl i 2 add get ctrl i 2 sub get sub def
/dy ctrl i 3 add get ctrl i 1 sub get sub def
/l dx 2 exp dy 2 exp add sqrt def
dx l div dy l div
} for
0 0] def
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 sub { /i exch 2 mul def
/l
ctrl i 2 add get /x ctrl i get def x sub 2 exp
ctrl i 3 add get /y ctrl i 1 add get def y sub 2 exp add sqrt .5 mul
def
x xyA i get l mul add
y xyA i 1 add get l mul add
/x ctrl i 2 add get def
/y ctrl i 3 add get def
x xyA i 2 add get l mul sub
y xyA i 3 add get l mul sub
x y curveto
} for
} {
0 0 moveto
} ifelse
} def

/bez {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 add 3 div cvi 2 sub { /i exch 6 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get ctrl i 5 add get
ctrl i 6 add get ctrl i 7 add get curveto
} for
/i nctrl 3 sub 3 div cvi 3 mul def
i nctrl 3 sub eq {
/i i 1 add 2 mul def
ctrl i get ctrl i 1 add get
ctrl i 2 add get ctrl i 3 add get
ctrl 0 get ctrl 1 get curveto
} if
closepath
} { 0 0 moveto } ifelse
} def

/bezO {
nctrl 4 ge {
ctrl 0 get ctrl 1 get moveto
0 1 nctrl 2 add 3 div cvi 2 sub { /i exch 6 mul def
ctrl i 2 add get ctrl i 3 add get
ctrl i 4 add get ctrl i 5 add get
ctrl i 6 add get ctrl i 7 add get curveto
} for
} { 0 0 moveto } ifelse
} def

/rect {
	nctrl 2 ge {
		/x1 ctrl 0 get def /y1 ctrl 1 get def /x2 ctrl 2 get def /y2 ctrl 3 get def
		x1 y1 moveto x2 y1 lineto x2 y2 lineto x1 y2 lineto closepath
	} { 0 0 moveto } ifelse
} def

/pol {
	nctrl 2 ge {
		ctrl 0 get ctrl 1 get moveto
		1 1 nctrl 1 sub { /i exch 2 mul def
		ctrl i get ctrl i 1 add get lineto } for
		closepath
	} { 0 0 moveto } ifelse
	/D 1 def
} def

/polO {
	nctrl 2 ge {
		ctrl 0 get ctrl 1 get moveto
		1 1 nctrl 1 sub { /i exch 2 mul def
		ctrl i get ctrl i 1 add get lineto } for
	} { 0 0 moveto } ifelse
} def

/arcP {
	nctrl 3 ge {
		/x ctrl 0 get def /y ctrl 1 get def
		x y moveto
		x y
		/x1 ctrl 2 get x sub def
		/y1 ctrl 3 get y sub def
		/x2 ctrl 4 get x sub def
		/y2 ctrl 5 get y sub def
		x1 2 exp y1 2 exp add sqrt
		y1 x1 atan
		y2 x2 atan
		arc closepath
	} { 0 0 moveto } ifelse
} def

/arcPO {
	nctrl 3 ge {
		/x ctrl 0 get def /y ctrl 1 get def
		x y
		/x1 ctrl 2 get x sub def
		/y1 ctrl 3 get y sub def
		/x2 ctrl 4 get x sub def
		/y2 ctrl 5 get y sub def
		x1 2 exp y1 2 exp add sqrt
		y1 x1 atan
		y2 x2 atan
		arc
	} { 0 0 moveto } ifelse
} def

/rrect {
	/ci 10 def
	udt
	nctrl 2 ge {
	/x1 ctrl 0 get def /y1 ctrl 1 get def /x2 ctrl 2 get def /y2 ctrl 3 get def
	x2 ci sub y1 ci add ci -90 0 arc
	x2 ci sub y2 ci sub ci 0 90 arc
	x1 ci add y2 ci sub ci 90 180 arc
	x1 ci add y1 ci add ci 180 270 arc closepath
	} { 0 0 moveto } ifelse
} def

/dFS {
	cl setrgbcolor
	cp
	gsave
	cfl
	grestore
	setrgbcolor
	cst
} def
/dFSBB { fsbb } def

/dS {
	cl pop pop pop setrgbcolor
	cp
	cst
} def
/dSBB { fsbb } def

/dF {
	cl setrgbcolor
	cp
	cfl
	pop pop pop
} def
/dFBB { fbb } def

/dSF {
cl 6 3 roll setrgbcolor
cp gsave cst grestore
setrgbcolor cfl
} def
/dSFBB { fsbb } def

/dsh {
	/dpt [5 5] def
	udt
	dpt 0 setdash
	stroke
	[] 0 setdash
} def

/dbl {
	gsave currentlinewidth 2 mul setlinewidth stroke grestore
	1 setgray stroke
} def

/qual 1 def

/SET {
/i exch def
i length 1 sub -1 0 {
i exch get exch def
} for
} def

/doClip {
gsave newpath
initmatrix cp pathbbox grestore
[/x1 /y1 /x2 /y2] SET
gsave
clip newpath
x1 y1 translate
/width x2 x1 sub def
/height y2 y1 sub def
} def

/endClip {
grestore
newpath
} def

/grid {
/st 5 def
udt
doClip
0 st height { 0 exch moveto width 0 rlineto stroke
} for
0 st width { 0 moveto 0 height rlineto stroke } for
endClip
} def

/hrL {
/st 5 def
udt
doClip
0 st height { 0 exch moveto width 0 rlineto stroke
} for
endClip
} def

/vrL {
/st 5 def
udt
doClip
0 st width { 0 moveto 0 height rlineto stroke } for
endClip
} def

% END PENCIL printing Package

% PENCIL printing Package EXTRAS

/dFSSh {
	/shadowgray .2 def
	gsave
	5 -5 translate
	udt shadowgray setgray /shadowgray .2 def
	cp
	fill
	grestore
	cl setrgbcolor
	cp
	gsave
	cfl
	grestore
	setrgbcolor
	cst
} def
/dFSShBB { fsbb 0 -5 5 0 enlbb } def

/dSSh {
	gsave
	5 -5 translate
	/shadowgray .2 def udt shadowgray setgray 
	cp
	cst
	grestore
	cl pop pop pop setrgbcolor
	cp
	cst
} def
/dSShBB { fsbb 0 -5 5 0 enlbb } def

/dFSh {
	gsave
	5 -5 translate
	/shadowgray .2 def udt shadowgray setgray
	cp
	fill
	grestore
	cl setrgbcolor pop pop pop
	cp
	cfl
} def
/dFShBB { fbb 0 -5 5 0 enlbb } def

/d3D {
	cl setrgbcolor pop pop pop
	gsave
	-2 2 translate
	currenthsbcolor pop pop .5 1 sethsbcolor
	cp fill
	grestore
	gsave
	2 -2 translate
	currenthsbcolor pop .2 sethsbcolor
	cp fill
	grestore
	cp cfl
} def
/d3DBB { fsbb } def

/d3DSh {
	cl setrgbcolor
	gsave
	5 -5 translate
	.3 setgray
	cp fill
	grestore
	gsave
	-2 2 translate
	currenthsbcolor pop pop .5 1 sethsbcolor
	cp fill
	grestore
	gsave
	2 -2 translate
	currenthsbcolor pop .2 sethsbcolor
	cp fill
	grestore
	cp cfl
} def
/d3DShBB { fsbb 0 -5 5 0 enlbb } def

/grad {
/phi 0 def
udt
cl [/r1 /g1 /b1 /r2 /g2 /b2] SET
/r2 r2 r1 sub def
/g2 g2 g1 sub def
/b2 b2 b1 sub def
gsave newpath initmatrix cp pathbbox grestore
[/x1 /y1 /x2 /y2] SET
gsave
clip
newpath
x1 y1 translate
/x x2 x1 sub def
/y y2 y1 sub .1 add def
phi 0 ne { phi neg rotate } if
y phi sin mul neg 0 translate
/l y phi sin mul x phi cos mul add def
dg {
0 1 y phi cos mul x phi sin mul add qual div .5 add div 2 mul 1.01 { /i exch def
r1 i r2 mul add g1 i g2 mul add b1 i b2 mul add setrgbcolor
0 0 l qual rectfill 0 qual translate
} for
0 1 y phi cos mul x phi sin mul add qual div .5 add div 2 mul 1.01 { /i exch 1 sub neg def
r1 i r2 mul add g1 i g2 mul add b1 i b2 mul add setrgbcolor
0 0 l qual rectfill 0 qual translate
} for
} {
0 1 y phi cos mul x phi sin mul add qual div .5 add div 1.01 { /i exch def
r1 i r2 mul add g1 i g2 mul add b1 i b2 mul add setrgbcolor
0 0 l qual rectfill 0 qual translate
} for
} ifelse
grestore
newpath
} def

/grd { /dg false def grad } def
/dgrd { /dg true def grad } def

/sphGrad {
/centerR .2 def
/centerX .4 def
cl [/r1 /g1 /b1 /r2 /g2 /b2] SET
/b2 b2 b1 sub def
/g2 g2 g1 sub def
/r2 r2 r1 sub def
udt
gsave newpath initmatrix cp pathbbox grestore
[/x1 /y1 /x2 /y2] SET
gsave
clip
x1 x2 add 2 div y1 y2 add 2 div translate
/dy x2 x1 sub 2 div def
/l dy 1 centerR sub mul qual div cvi 5 add def
/dx centerR 1 l div exp def
/st centerX dy mul dx div 1 dx sub mul 1 dx l exp sub div def
0 1 l {
/i exch l div def
r1 r2 i mul add
g1 g2 i mul add
b1 b2 i mul add
setrgbcolor
0 0 dy 0 360 arc fill
st neg  st translate
dx dup scale
} for
grestore
newpath
} def

/gstroke {
/l currentlinewidth def
cl [/r1 /g1 /b1 /r2 /g2 /b2] SET
/r1 r1 r2 sub def
/g1 g1 g2 sub def
/b1 b1 b2 sub def
1 -.1 0 { /i exch def
i l mul setlinewidth
r2 r1 i mul add g2 g1 i mul add b2 b1 i mul add setrgbcolor
gsave stroke grestore
} for
newpath
} def
% END of EXTRAS

% PENCIL EFFECTS1
/hair {
	/l currentlinewidth def
	/st 1 def
	udt
	/i 1 def
	l st neg 0 { 
	i setgray
	setlinewidth
	gsave stroke grestore
	/i 1 i sub def
	} for
	newpath
} def
% END EFFECTS1


/qual 1 def

1 setgray
52.5 78.5 33 28 rectclip
52.5 78.5 33 28 rectfill
gsave
-24 -13 translate
 /udt {  } def  /ctrl [78 93 80 118 106 117 108 93]
 def 0 setlinewidth 0 setgray /nctrl 4 def bezO stroke
grestore
grestore
%%Trailer

%%EndDocument
count __NXEPSOpCount sub {pop} repeat countdictstack __NXEPSDictCount sub {end} repeat __NXEPSSave restore
grestore
grestore
grestore
grestore
gsave
0 0 309 668 rectclip
[1 0 0 -1 0 668] concat
gsave
grestore
grestore
grestore
%%Trailer
